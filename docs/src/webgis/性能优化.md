# 前端性能优化

## 一、网络加载优化

### 1. 减少 HTTP 请求

**合并文件**：在前端开发中，每引入一个 JS 或 CSS 文件，浏览器就需要发起一次 HTTP 请求。如果页面依赖很多小文件，会导致大量的请求，增加网络延迟和服务器压力，影响页面加载速度。

```javascript
// 使用构建工具如webpack合并JS/CSS
module.exports = {
  entry: {
    app: "./src/index.js",
    vendor: ["react", "react-dom"],
  },
  output: {
    filename: "[name].bundle.js",
  },
};
```

通过配置 Webpack 会把多个 JS 文件合并成少数几个 bundle 文件（如 app.bundle.js、vendor.bundle.js）。浏览器只需请求这几个合并后的文件，而不是大量零散的小文件。这样大大减少了 HTTP 请求次数，提升了首屏加载速度和整体性能。

### 2. 启用压缩

**Gzip 压缩**（Nginx 配置）：在 Web 服务中，前端资源（如 HTML、CSS、JS、JSON 等）默认是以原始文本形式传输的，体积较大。通过在服务器（如 Nginx）上开启 Gzip 压缩，可以在资源发送给浏览器前，将其压缩成更小的体积，浏览器收到后再自动解压，还原为原始内容。

```nginx
gzip on;//开启 Gzip 压缩功能
<!-- 指定哪些类型的文件启用压缩（如文本、CSS、JS、JSON 等）。 -->
gzip_types text/plain text/css application/json application/javascript;
<!-- 只有大于 1000 字节的文件才会被压缩，避免小文件压缩反而增加负担。 -->
gzip_min_length 1000;
```

资源压缩后体积大幅减小，通常可减少 60%~80% 的传输数据量。浏览器和服务器都支持 Gzip，解压过程对用户无感知。体积变小后，网络传输更快，页面加载速度提升，尤其在带宽有限或移动端网络下效果更明显。

### 3. 使用 CDN

```html
<script src="https://cdn.jsdelivr.net/npm/vue@3.2.31/dist/vue.global.min.js"></script>
```

优化原理：

- 就近访问：用户会从最近的 CDN 节点获取资源，减少网络延迟，提升加载速度。
- 高可用性：CDN 节点分布广泛，即使部分节点故障，用户也能从其他节点获取资源，提升网站稳定性。
- 减轻源站压力：静态资源由 CDN 托管，减少了源服务器的带宽和请求压力。
- 缓存命中率高：热门库（如 Vue、React 等）被大量网站使用，用户浏览多个网站时，浏览器可能已缓存这些 CDN 资源，无需重复下载，进一步加快加载速度。

### 4. 缓存策略

**Service Worker 缓存**：Service Worker 是浏览器在后台运行的独立线程，可以拦截和处理网络请求，实现资源缓存、离线访问、消息推送等功能。

```javascript
// sw.js
const CACHE_NAME = "v1"; //定义缓存的名称，方便后续管理和版本更新。
const urlsToCache = ["/", "/styles/main.css"]; //指定需要缓存的资源列表（如首页和主样式表）。

//监听 Service Worker 的安装事件，在安装时将指定的资源缓存到本地。
self.addEventListener("install", (event) => {
  event.waitUntil(
    // 打开指定名称的缓存空间，并把资源列表全部缓存下来。
    caches.open(CACHE_NAME).then((cache) => cache.addAll(urlsToCache))
  );
});
```

## 二、资源加载优化

### 1. 懒加载

**图片懒加载**：

```html
<img data-src="image.jpg" class="lazyload" />

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const lazyImages = [].slice.call(document.querySelectorAll("img.lazyload"));

    if ("IntersectionObserver" in window) {
      let lazyImageObserver = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            let lazyImage = entry.target;
            lazyImage.src = lazyImage.dataset.src;
            lazyImageObserver.unobserve(lazyImage);
          }
        });
      });

      lazyImages.forEach((lazyImage) => {
        lazyImageObserver.observe(lazyImage);
      });
    }
  });
</script>
```

### 2. 预加载关键资源

核心思想是提前加载关键资源，延后加载非关键资源，提升首屏速度和整体体验

```html
<!-- 告诉浏览器“critical.css”是当前页面渲染非常重要的资源，应该优先加载。这样可以加快关键 CSS 的获取和渲染速度，减少首屏白屏时间。 -->
<link rel="preload" href="critical.css" as="style" />
<!-- 告诉浏览器“next-page.js”是后续可能用到的资源（如下一个页面的 JS），可以在浏览器空闲时提前下载，等真正需要时能更快加载，提升页面切换体验。 -->
<link rel="prefetch" href="next-page.js" as="script" />
```

### 3. 异步加载非关键 JS

```html
<!-- 让js在 HTML 解析完成后再执行，不会阻塞页面渲染，适合统计、监控等非核心 JS。 -->
<script defer src="analytics.js"></script>
<!-- 让js异步加载并尽快执行，也不会阻塞页面渲染，适合第三方插件等非关键 JS。 -->
<script async src="social-widget.js"></script>
```

## 三、渲染性能优化

### 1. 减少重绘重排

**批量 DOM 操作**：每次对 DOM 进行插入、删除、样式修改等操作时，都会引发页面的重排（Reflow）和重绘（Repaint）。如果频繁地逐个插入元素（如循环中直接 appendChild），浏览器会多次进行重排和重绘，极大地影响性能，尤其是在大量 DOM 操作时。

```javascript
// 不好
for (let i = 0; i < 100; i++) {
  document.body.appendChild(document.createElement("div"));
}

// 先把所有新元素添加到内存中的 DocumentFragment（不会引发页面渲染），最后一次性把 fragment 添加到页面，只触发一次重排和重绘。
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
  fragment.appendChild(document.createElement("div"));
}
document.body.appendChild(fragment);
```

### 2. 使用 CSS3 硬件加速

在浏览器中，普通的样式变换（如 left/top/width/height 等）通常由 CPU 计算并在主线程上完成，容易造成卡顿。而使用某些 CSS3 属性（如 transform: translateZ(0) 或 will-change: transform），可以让浏览器将该元素提升到 GPU 层，由显卡进行加速渲染。

```css
.animate {
  transform: translateZ(0);
  /* 告诉浏览器该元素即将发生 transform 变化，提前为其做优化准备（如分层、开启硬件加速）。 */
  will-change: transform;
}
```

### 3. 虚拟列表（大数据量渲染）

```javascript
// 使用react-window库示例
import { FixedSizeList as List } from "react-window";

const Row = ({ index, style }) => <div style={style}>Row {index}</div>;

const Example = () => (
  <List height={400} itemCount={1000} itemSize={35} width={300}>
    {Row}
  </List>
);
```

## 四、JavaScript 优化

### 1. 防抖节流

**防抖**：

```javascript
function debounce(func, wait) {
  let timeout;
  return function () {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, arguments), wait);
  };
}

window.addEventListener(
  "resize",
  debounce(() => {
    console.log("Resize handler");
  }, 200)
);
```

**节流**：

```javascript
function throttle(func, limit) {
  let inThrottle;
  return function () {
    if (!inThrottle) {
      func.apply(this, arguments);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}

window.addEventListener(
  "scroll",
  throttle(() => {
    console.log("Scroll handler");
  }, 100)
);
```

### 2. Web Worker 处理耗时任务

```javascript
// main.js
const worker = new Worker("worker.js");
worker.postMessage({ data: largeData });

worker.onmessage = (e) => {
  console.log("Result:", e.data);
};

// worker.js
self.onmessage = (e) => {
  const result = processData(e.data);
  self.postMessage(result);
};
```

## 五、监控与分析

### 1. Performance API

```javascript
// 测量代码执行时间
performance.mark("start");
// 执行代码...
performance.mark("end");
performance.measure("My Measure", "start", "end");

const measures = performance.getEntriesByName("My Measure");
console.log(measures[0].duration);
```

### 2. 长任务监控

```javascript
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    console.log("Long task:", entry);
  }
});
observer.observe({ entryTypes: ["longtask"] });
```

## 六、构建优化

### 1. 代码分割

```javascript
// 动态导入
const module = await import("./module.js");

// React懒加载
const OtherComponent = React.lazy(() => import("./OtherComponent"));
```

### 2. Tree Shaking

```javascript
// webpack.config.js
module.exports = {
  mode: "production",
  optimization: {
    usedExports: true,
  },
};
```

### 3. 按需加载 Polyfill

```javascript
// 使用polyfill.io
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6,IntersectionObserver"></script>
```

## Cesium 性能优化方式与实践

### 一、数据加载与管理优化

1. 影像与地形数据优化

   使用合适分辨率的瓦片服务

   - 只加载当前视野和缩放级别所需的瓦片，避免一次性加载全图。
   - 选择合适的 maximumLevel，防止过度细分导致瓦片数量爆炸。

   ```js
   const imageryProvider = new Cesium.UrlTemplateImageryProvider({
     url: "https://your-tileserver/{z}/{x}/{y}.png",
     maximumLevel: 16, // 限制最大缩放级别
   });
   viewer.imageryLayers.addImageryProvider(imageryProvider);
   ```

   采用多级缓存的影像/地形服务:

   - 服务端开启缓存，减少重复请求。
   - 限制最大并发请求数

```js
Cesium.Resource.maximumRequestsPerServer = 6;
```

按需加载地形/影像图层
动态添加/移除图层，避免无用图层占用带宽和内存。

```js
// 添加图层
const layer = viewer.imageryLayers.addImageryProvider(imageryProvider);
// 移除图层
viewer.imageryLayers.remove(layer, true);
```

2. 矢量数据（GeoJSON、CZML、3D Tiles 等）优化

   数据裁剪与简化:

   - 只加载当前视野范围内的数据，后端接口支持 BBOX 裁剪。
   - 对 GeoJSON 等数据进行简化，减少顶点数量。

   ```js
   viewer.camera.moveEnd.addEventListener(() => {
     const extent = Cesium.Rectangle.toDegrees(
       viewer.camera.computeViewRectangle()
     );
     fetch(`/api/geojson?bbox=${extent.join(",")}`)
       .then((res) => res.json())
       .then((data) => {
         // 加载到地图
         Cesium.GeoJsonDataSource.load(data).then((ds) => {
           viewer.dataSources.add(ds);
         });
       });
   });
   ```

   分块/分级加载:
   大型数据集采用分块（如 3D Tiles 分层结构），按需加载。

   ```js
   const tileset = new Cesium.Cesium3DTileset({
     url: "https://your-server/tileset.json",
   });
   viewer.scene.primitives.add(tileset);
   ```

   属性精简:
   只保留前端实际需要的属性，减少数据体积。

   3D Tiles 优化：

   - 使用 3d-tiles-tools 等工具对 3D Tiles 数据进行合并、压缩（如 Draco 压缩）、裁剪。
   - 合理设置 geometricError，避免过度细分。

3. 实时数据流优化

   数据增量更新：

   - 只推送变化部分，避免全量刷新。
   - WebSocket/HTTP2：使用高效的实时通信协议，减少延迟和带宽占用。

### 二、渲染与显示优化

1. 图层与实体管理
   减少实体数量
   批量渲染（如 PrimitiveCollection、PointPrimitiveCollection），避免大量单独的 Entity。

   ```js
   const pointCollection = viewer.scene.primitives.add(
     new Cesium.PointPrimitiveCollection()
   );
   pointCollection.add({
     position: Cesium.Cartesian3.fromDegrees(120, 30),
     color: Cesium.Color.RED,
     pixelSize: 10,
   });
   ```

   合并同类图元
   同一类型的点/线/面合并为一个 Primitive，减少 Draw Call。
   按需显示/隐藏
   视野外的实体及时隐藏或移除，减少渲染压力。

   ```js
   entity.show = false; // 隐藏实体
   ```

   分级显示（LOD）
   远距离时显示简化模型，近距离时显示高精度模型。

   ```js
   tileset.maximumScreenSpaceError = 16; // 远距离时允许更大误差
   ```

2. 材质与贴图优化
   压缩贴图
   使用 WebP、JPEG 等压缩格式，减小贴图体积。
   贴图分辨率自适应
   远距离时加载低分辨率贴图，近距离时再加载高分辨率贴图。
3. 动画与特效优化
   减少实时动画数量
   只对当前视野内、用户关注的对象做动画。
   粒子系统优化
   限制粒子数量，降低粒子生命周期，减少 CPU/GPU 负载。
   ```js
   const particleSystem = viewer.scene.primitives.add(
     new Cesium.ParticleSystem({
       // ...参数
       maximumParticleLife: 2.0,
       emissionRate: 10,
     })
   );
   ```

### 三、内存与资源管理

及时销毁无用对象

```js
viewer.imageryLayers.remove(layer, true); // true表示销毁
tileset.destroy();
```

定期清理缓存
对自定义缓存、图片、模型等资源定期清理。
监控内存占用
利用浏览器开发者工具、Cesium Inspector 等工具监控内存变化。

### 四、网络与请求优化

开启 HTTP 压缩
服务端开启 GZIP/Brotli 压缩，减少传输体积。
CDN 加速
静态资源、瓦片服务等接入 CDN，提升加载速度。
请求合并与去重
合并小请求，避免重复请求同一资源。

### 五、代码与架构优化

异步加载与懒加载
大型模型、数据集采用异步加载，用户操作时再加载相关资源。

```js
async function loadTileset(url) {
  const tileset = await Cesium.Cesium3DTileset.fromUrl(url);
  viewer.scene.primitives.add(tileset);
}
```

Web Worker 多线程
复杂计算、数据解析放到 Web Worker 中，避免主线程卡顿。
事件节流与防抖
地图交互相关事件做节流处理，减少无效刷新。

```js
function throttle(fn, delay) {
  let last = 0;
  return function (...args) {
    const now = Date.now();
    if (now - last > delay) {
      last = now;
      fn.apply(this, args);
    }
  };
}
viewer.camera.moveEnd.addEventListener(
  throttle(() => {
    // 处理逻辑
  }, 500)
);
```

### 六、Cesium 配置参数优化

帧率限制

```js
viewer.targetFrameRate = 30;
```

关闭不必要的特性

```js
viewer.shadows = false;
viewer.scene.globe.enableLighting = false;
```

优化渲染循环

```js
const viewer = new Cesium.Viewer("cesiumContainer", {
  requestRenderMode: true,
  maximumRenderTimeChange: Infinity,
});
```

### 七、调试与监控工具

Cesium Inspector
检查瓦片加载、渲染状态、内存占用等。
浏览器性能分析工具
Chrome DevTools、Firefox Profiler 等分析 JS 执行、内存、网络瓶颈。
自定义监控
统计瓦片加载数、帧率、内存等关键指标，及时报警。
典型优化实践举例

1. 大规模点云/模型加载
   使用 3D Tiles 格式，后端预处理分层分块，前端按需加载。
   开启 Draco 压缩，减少网络传输和内存占用。
2. 大范围地形/影像加载
   只加载当前视野范围，切换区域时动态卸载旧区域数据。
   采用多级缓存和 CDN 加速。
3. 高并发数据流场景
   实时数据采用 WebSocket 推送，前端只更新变化部分。
   对历史轨迹等大数据，采用分段加载和简化算法。
4. 移动端适配
   降低最大帧率，关闭高消耗特性，限制最大实体数。
   总结
   Cesium 性能优化是一个系统工程，涉及数据、渲染、网络、内存、代码等多个层面。
   核心原则：
   按需加载，分级分块
   精简数据，合并渲染
   关闭无用特性，合理利用缓存
   监控与调优并重
