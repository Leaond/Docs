# 软件设计模式

设计模式是一套被反复使用、多数人知晓的、代码设计经验的总结。它描述了在软件设计过程中的一些不断发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路。

## 单例模式（Singleton）

- 目的：确保一个类只有一个实例，并提供全局访问点。
- 适用场景：全局状态管理、共享资源（如 Redux Store、日志服务、Websocket 连接等）

### 实现方式

ES6 实现

```js
class Singleton {
  private static instance: Singleton;

  private constructor() {} // 防止外部 new

  public static getInstance(): Singleton {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }

  public someMethod() {
    console.log("Singleton method");
  }
}

// 使用
const instance1 = Singleton.getInstance();
const instance2 = Singleton.getInstance();
console.log(instance1 === instance2); // true
```

模块实现

```js
// 模块本身就是单例
const singleton = {
  data: "some data",
  method() {
    console.log("Singleton method");
  },
};

export default singleton;
```

闭包实现

```js
const Singleton = (() => {
  let instance;

  function createInstance() {
    return {
      data: "some data",
      method() {
        console.log("Singleton method");
      },
    };
  }

  return {
    getInstance() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    },
  };
})();

// 使用
const instance1 = Singleton.getInstance();
const instance2 = Singleton.getInstance();
console.log(instance1 === instance2); // true
```

## 工厂模式（Factory）

**简单工厂模式**的核心是定义一个创建对象的接口，将对象的创建和本身的业务逻辑分离，降低系统的耦合度，使得两个修改起来相对容易些，档以后实现改变时，只需要修改工厂类即可。

优缺点：简单工厂模式提供专门的工厂类用于创建对象，实现了对象创建和使用的职责分离，客户端不需知道所创建的具体产品类的类名以及创建过程，只需知道具体产品类所对应的参数即可，通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。
缺点：不符合“开闭原则”，每次添加新产品就需要修改工厂类。在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展维护，并且工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。

**工厂方法模式**将工厂抽象化，并定义一个创建对象的接口。每增加新产品，只需增加该产品以及对应的具体实现工厂类，由具体工厂类决定要实例化的产品是哪个，将对象的创建与实例化延迟到子类，这样工厂的设计就符合“开闭原则”了，扩展时不必去修改原来的代码。缺点在于，每增加一个产品都需要增加一个具体产品类和实现工厂类，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。

- 目的：封装对象的创建逻辑，让调用者无需关心具体实现
- 适用场景：动态创建对象，如 UI 组件、API 客户端。

### 实现方式

```js
interface Button {
  render(): void;
}

class WindowsButton implements Button {
  render() {
    console.log("Render Windows-style button");
  }
}

class MacButton implements Button {
  render() {
    console.log("Render Mac-style button");
  }
}

class ButtonFactory {
  static createButton(os: "windows" | "mac"): Button {
    switch (os) {
      case "windows":
        return new WindowsButton();
      case "mac":
        return new MacButton();
      default:
        throw new Error("Unsupported OS");
    }
  }
}

// 使用
const button = ButtonFactory.createButton("mac");
button.render(); // "Render Mac-style button"
```

## 观察者模式（Observer）

观察者模式指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式又被称为 发布-订阅模式、模型-视图模式。

- 目的：定义对象间的一对多的依赖关系，当一个对象状态改变时，所有依赖它的对象都会收到通知。
- 适用场景：事件系统、数据绑定

优点：降低了目标域观察者之间的耦合关系，两者之间是抽象耦合关系。目标域观察者之间建立了一套触发机制。
缺点：目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。

```js
class Subject {
  private observers: Observer[] = [];

  public addObserver(observer: Observer) {
    this.observers.push(observer);
  }

  public removeObserver(observer: Observer) {
    this.observers = this.observers.filter(obs => obs !== observer);
  }

  public notify(data: string) {
    this.observers.forEach(observer => observer.update(data));
  }
}

interface Observer {
  update(data: string): void;
}

class ConcreteObserver implements Observer {
  update(data: string) {
    console.log(`Received data: ${data}`);
  }
}

// 使用
const subject = new Subject();
const observer1 = new ConcreteObserver();
const observer2 = new ConcreteObserver();

subject.addObserver(observer1);
subject.addObserver(observer2);

subject.notify("Hello Observers!");
// 输出：
// "Received data: Hello Observers!"
// "Received data: Hello Observers!"
```

## 策略模式（Strategy）

- 目的：定义一系列算法，使他们可以相互替换，让算法的变化独立于使用它的客户端
- 适用场景：如果在一个系统里面有许多类，他们之间的区别仅仅在于他们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。一个系统需要动态的在几种算法中选择一种。例如支付方式等。

优点：

- 算法可以自由切换
- 避免使用多重条件判断
- 扩展性良好（符合开闭原则）

缺点：

- 策略类会增多
- 所有策略类都需要对外暴露
- 客户端必须知道所有的策略类，才能确定要调用的策略类。

### 实现方式

```js
interface PaymentStrategy {
  pay(amount: number): void;
}

class CreditCardPayment implements PaymentStrategy {
  pay(amount: number) {
    console.log(`Paid ${amount} via Credit Card`);
  }
}

class PayPalPayment implements PaymentStrategy {
  pay(amount: number) {
    console.log(`Paid ${amount} via PayPal`);
  }
}

class PaymentContext {
  private strategy: PaymentStrategy;

  constructor(strategy: PaymentStrategy) {
    this.strategy = strategy;
  }

  executePayment(amount: number) {
    this.strategy.pay(amount);
  }
}

// 使用
const creditCardPayment = new CreditCardPayment();
const paypalPayment = new PayPalPayment();

const paymentContext = new PaymentContext(creditCardPayment);
paymentContext.executePayment(100); // "Paid 100 via Credit Card"

paymentContext.strategy = paypalPayment;
paymentContext.executePayment(200); // "Paid 200 via PayPal"
```

## 装饰器模式（Decorator）

- 目的：动态扩展对象的功能，而不改变其内部结构
- 适用场景：高阶组件、日志增强、权限控制。

### 实现方式

```js
interface Coffee {
  cost(): number;
  description(): string;
}

class SimpleCoffee implements Coffee {
  cost() {
    return 10;
  }
  description() {
    return "Simple coffee";
  }
}

class MilkDecorator implements Coffee {
  constructor(private coffee: Coffee) {}

  cost() {
    return this.coffee.cost() + 2;
  }
  description() {
    return `${this.coffee.description()}, with milk`;
  }
}

class SugarDecorator implements Coffee {
  constructor(private coffee: Coffee) {}

  cost() {
    return this.coffee.cost() + 1;
  }
  description() {
    return `${this.coffee.description()}, with sugar`;
  }
}

// 使用
let coffee: Coffee = new SimpleCoffee();
console.log(coffee.description(), coffee.cost()); // "Simple coffee", 10

coffee = new MilkDecorator(coffee);
console.log(coffee.description(), coffee.cost()); // "Simple coffee, with milk", 12

coffee = new SugarDecorator(coffee);
console.log(coffee.description(), coffee.cost()); // "Simple coffee, with milk, with sugar", 13
```

## 软件设计原则

### 单一职责原则 SRP

核心思想是每个模块都应该只有一个功能，即职责。如果一个模块上有多个职责，某个职责的改变可能改变其他职责的正常工作，比如某个职责失效导致该模块下线，同一模块上的其他职责也就不能发挥作用了。

本质上就是模块内内聚性强、模块间耦合性弱的具体体现。

### 里氏替换原则 LSP

核心思想是一个子类应该可以完全替代它的父类，并且保持程序的正确性和一致性。这样保障了程序的稳定性，即使后面不断更新子类，程序原有功能不受影响。如果子类不能完整的实现父类的方法，或者父类的某些方法在子类中已经发生 畸变，则建议断开父子继承关系。

具体来说，子类应该是一个父类的具体化（即父类中的抽象方法在子类中定义具体实现），但不能是父类的特殊约束。比如，动物类是一个抽象基类，他有一个抽象方法叫 makeSound，狗类和猫类的子类中对叫声分别进行了定义，这是符合里氏替换原则的。再比如，正方形作为长方形的子类就违背了里氏替换原则，因为子类中要求四边一样长。

### 依赖倒置原则 DIP

高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。高层模块就是调用端，低层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类。

所谓依赖倒置，就是把高层依赖低层，改成高层和低层都依赖中间的抽象。

### 接口隔离原则 ISP

核心思想是类间的依赖关系应该建立在最小的接口上。通俗来讲：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是会所，我们要为各类建立专用的接口，而不要试图去建立一个庞大的接口供所有依赖它的类去调用。

所谓接口隔离原则，就是只暴露给调用的类它需要的方法，它不需要的方法则隐藏隔离起来。

### 开放封闭原则 OCP

核心思想是尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化。通过面向对象的继承和多态机制支持扩展。

### 迪米特法则 LoD

核心思想是一个对于其他类知道的越少越好。有两个具体原则：只和直接的朋友交流（直接的朋友就是成员变量、成员方法输入输出参数中的类），减少对朋友的了解。

只和直接的朋友交流，可以理解成朋友越少越好。

### 合成/聚合复用原则 CARP

优先使用对象组合/聚合，而不是通过继承来实现代码复用。该原则旨在提高代码的灵活性和可维护性，减少类之间的紧密耦合。

聚合是 has-A 类，关系较弱，部分与整体的生命周期无关；组合是 contains-A 关系，关系较弱，部分与整体的生命周期有关；继承是 is-A 类，前者包含了后者全部东西。
