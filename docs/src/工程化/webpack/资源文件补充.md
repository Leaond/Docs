# babel
Babel 是一个工具链，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。

babel能做的事：
- 语法转换
- 通过 Polyfill 方式在目标环境中添加缺失的功能（通过引入第三方 polyfill 模块，例如 core-js）
- 源码转换（codemods）

```js
// Babel 接收到的输入是： ES2015 箭头函数
[1, 2, 3].map(n => n + 1);

// Babel 输出： ES5 语法实现的同等功能
[1, 2, 3].map(function(n) {
  return n + 1;
});
```

 ## 配置文件

 根ESlint一样，babel的配置文件格式也有很多种：

 - `babel.config.*`：新建文件，位于项目根目录
  - `babel.config.js`
  - `babel.config.json`
- `.babelrc.*`：新建文件，位于项目根目录
  - `.babelrc`
  - `.babelrc.js`
  - `.babelrc.json`
- `package.json` 中 `babel`：不需要创建文件，在原有文件基础上写。

babel会自动的查找和读取他们，我们只需要按照上面的格式创建一个就行。

## 配置

```js
// babel.config.js
module.exports = {
  // 预设 : 预设可以简单的理解为babel的插件，用来扩展babel的功能。
  presets: [],
};
```

- `@babel/preset-env`: 一个智能预设，允许您使用最新的 JavaScript。
- `@babel/preset-react`：一个用来编译 React jsx 语法的预设
- `@babel/preset-typescript`：一个用来编译 TypeScript 语法的预设

## 在webpack中的使用

下载
```js
npm i babel-loader @babel/core @babel/preset-env -D
```

创建配置文件

```js
// babel.config.js
module.exports = {
  presets: ["@babel/preset-env"],
};
```

```js{40-44}
// webpack.config.js
module.exports = {
  // 入口
  entry: "./src/main.js",
  // 输出
  output: {},
  // 加载器
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: ['style-loader', 'css-loader'],
      },
      {
        test: /\.less$/i,
        use: [
          // compiles Less to CSS
          'style-loader',
          'css-loader',
          'less-loader',
        ],
      },
      {
        test: /\.s[ac]ss$/i,
        use: [
          // 将 JS 字符串生成为 style 节点
          'style-loader',
          // 将 CSS 转化成 CommonJS 模块
          'css-loader',
          // 将 Sass 编译成 CSS
          'sass-loader',
        ],
      },
      {
        test: /\.styl$/,
        use: ["style-loader", "css-loader", "stylus-loader"],
      },
      {
        test: /\.js$/,
        exclude: /node_modules/, // 排除node_modules代码不编译
        loader: "babel-loader",
      },
    ],
  },
  // 插件
  plugins: [],
  // 模式
  mode: "development",
  
};

```
因为我们之前在js文件中已经使用了ES6的箭头函数，所以我们现在可以直接进行打包，观察输出产物中箭头函数已经被编译成了普通函数。
![babel]('../../../../images/webpack/babel1.png')


# js资源处理

在我们之前的例子中，我们是手动将打包后的dist的入口文件引入到我们自己创建的一个index.html的文件中,然后再打开这个index.html文件实现预览的。现在我们可以使用插件来自动引入。

下载包
```js
npm i html-webpack-plugin -D
```

配置

```js{50-54}
module.exports = {
  // 入口
  entry: "./src/main.js",
  // 输出
  output: {},
  // 加载器
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: ['style-loader', 'css-loader'],
      },
      {
        test: /\.less$/i,
        use: [
          // compiles Less to CSS
          'style-loader',
          'css-loader',
          'less-loader',
        ],
      },
      {
        test: /\.s[ac]ss$/i,
        use: [
          // 将 JS 字符串生成为 style 节点
          'style-loader',
          // 将 CSS 转化成 CommonJS 模块
          'css-loader',
          // 将 Sass 编译成 CSS
          'sass-loader',
        ],
      },
      {
        test: /\.styl$/,
        use: ["style-loader", "css-loader", "stylus-loader"],
      },
      {
        test: /\.js$/,
        exclude: /node_modules/, // 排除node_modules代码不编译
        loader: "babel-loader",
      },
    ],
  },
  // 插件
  plugins: [
    // new ESLintWebpackPlugin({
    //   // 指定检查文件的根目录
    //   context: path.resolve(__dirname, "src"),
    // }),
    new HtmlWebpackPlugin({
      // 以 public/index.html 为模板创建文件
      // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源
      template: path.resolve(__dirname, "public/index.html"),
    }),
  ],
  // 模式
  mode: "development",
  
};
```

同时对index.html文件进行更改：去掉引入js的语句，因为这个插件会根据我们的模版index.html生成一个html文件，可以自动引入打包后的入口文件js。再执行打包命令我们可以发现dist的目录生成的index.html中会自动引入js文件。
![自动引入]()

# 开启服务器和自动化
在我们之前的每次修改都需要手动的开启打包命令，其实webpack提供了配置来开启一个服务器，这样在每次我们修改之后，就会进行自动的更新编译。

下载
```js
npm i webpack-dev-server -D
```
配置
```js
module.exports = {
  // 入口
  entry: "./src/main.js",
  // 输出
  output: {},
  // 加载器
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: ['style-loader', 'css-loader'],
      },
      {
        test: /\.less$/i,
        use: [
          // compiles Less to CSS
          'style-loader',
          'css-loader',
          'less-loader',
        ],
      },
      {
        test: /\.s[ac]ss$/i,
        use: [
          // 将 JS 字符串生成为 style 节点
          'style-loader',
          // 将 CSS 转化成 CommonJS 模块
          'css-loader',
          // 将 Sass 编译成 CSS
          'sass-loader',
        ],
      },
      {
        test: /\.styl$/,
        use: ["style-loader", "css-loader", "stylus-loader"],
      },
      {
        test: /\.js$/,
        exclude: /node_modules/, // 排除node_modules代码不编译
        loader: "babel-loader",
      },
    ],
  },
  // 插件
  plugins: [
    // new ESLintWebpackPlugin({
    //   // 指定检查文件的根目录
    //   context: path.resolve(__dirname, "src"),
    // }),
    new HtmlWebpackPlugin({
      // 以 public/index.html 为模板创建文件
      // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源
      template: path.resolve(__dirname, "public/index.html"),
    }),
  ],
   // 开发服务器
   devServer: {
    host: "localhost", // 启动服务器域名
    port: "3000", // 启动服务器端口号
    open: true, // 是否自动打开浏览器
  },
  // 模式
  mode: "development",
  
};
```

 运行指令

```js
npx webpack serve
```

**注意运行指令发生了变化**

并且当你使用开发服务器时，所有代码都会在内存中编译打包，并不会输出到 dist 目录下。

开发时我们只关心代码能运行，有效果即可，至于代码被编译成什么样子，我们并不需要知道。

# css文件的优化处理
在我们之前的学习中，css文件的打包是直接打包在入口文件中的，并且最终是通过style标签来生成样式的。但是在实际的项目中，壮会出现闪屏的现象，体验非常不好，所以我们现在需要将css文件单独打包成一个文件，然后通过link标签引入到html中，这样加载性能才会好。

```js
npm i mini-css-extract-plugin -D
```

配置: 我们需要引入这个插件，并且在loader中使用这个插件，并且还需要将style-loader屏蔽掉。
```js
const HtmlWebpackPlugin = require('html-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')


module.exports = {
  // 入口
  entry: "./src/main.js",
  // 输出
  output: {},
  // 加载器
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: [MiniCssExtractPlugin.loader, 'css-loader'],
      },
      {
        test: /\.less$/i,
        use: [
          MiniCssExtractPlugin.loader,
          // compiles Less to CSS
          'css-loader',
          'less-loader',
        ],
      },
      {
        test: /\.s[ac]ss$/i,
        use: [
          MiniCssExtractPlugin.loader,
          // 将 CSS 转化成 CommonJS 模块
          'css-loader',
          // 将 Sass 编译成 CSS
          'sass-loader',
        ],
      },
      {
        test: /\.styl$/,
        use: [MiniCssExtractPlugin.loader, "css-loader", "stylus-loader"],
      },
      {
        test: /\.js$/,
        exclude: /node_modules/, // 排除node_modules代码不编译
        loader: "babel-loader",
      },
    ],
  },
  // 插件
  plugins: [
    // new ESLintWebpackPlugin({
    //   // 指定检查文件的根目录
    //   context: path.resolve(__dirname, "src"),
    // }),
    new HtmlWebpackPlugin({
      // 以 public/index.html 为模板创建文件
      // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源
      template: path.resolve(__dirname, "public/index.html"),
    }),
   // 提取css成单独文件
   new MiniCssExtractPlugin({
    // 定义输出文件名和目录
    filename: "static/css/main.css",
  }),
  ],
   // 开发服务器
  //  devServer: {
  //   host: "localhost", // 启动服务器域名
  //   port: "3000", // 启动服务器端口号
  //   open: true, // 是否自动打开浏览器
  // },
  // 模式
  mode: "production",
  
};
```

之后我们在进行打包编译，css文件都会被打包到一个单独的css文件之中了。

## css 兼容性处理

```js
npm i postcss-loader postcss postcss-preset-env -D

```

配置
```js
```

